package uttt.game;

import uttt.utils.Symbol;
import uttt.utils.Move;

public class SimulatorInterfaceImpl implements SimulatorInterface {

    private BoardInterface[] boards;
    private Symbol currentPlayerSymbol;
    private int lastSymbolIndex;

    public SimulatorInterfaceImpl() {
        BoardInterface board0 = new BoardInterfaceImpl();
        BoardInterface board1 = new BoardInterfaceImpl();
        BoardInterface board2 = new BoardInterfaceImpl();

        BoardInterface board3 = new BoardInterfaceImpl();
        BoardInterface board4 = new BoardInterfaceImpl();
        BoardInterface board5 = new BoardInterfaceImpl();
        BoardInterface board6 = new BoardInterfaceImpl();
        BoardInterface board7 = new BoardInterfaceImpl();
        BoardInterface board8 = new BoardInterfaceImpl();

        this.boards = new BoardInterface[] { board0, board1, board2, board3,
                board4, board5, board6, board7, board8 };

        this.currentPlayerSymbol = Symbol.EMPTY;
        this.lastSymbolIndex = -1;
    }

    public BoardInterface[] getBoards() {
        return this.boards;
    }

    public void setBoards(BoardInterface[] boards) throws IllegalArgumentException {
        if (boards == null || boards.length != 9) {
            throw new IllegalArgumentException();
        }

        this.boards = boards;
    }

    public Symbol getCurrentPlayerSymbol() {
        return this.currentPlayerSymbol;
    }

    public void setCurrentPlayerSymbol(Symbol symbol) throws IllegalArgumentException {
        if (symbol == null) {
            throw new IllegalArgumentException();
        }

        this.currentPlayerSymbol = symbol;
    }

    private void updateLastSymbolIndex(int markIndex) {
        if (this.boards[markIndex].isClosed()) {
            this.lastSymbolIndex = -1;
        } else {
            this.lastSymbolIndex = markIndex;
        }
    }

    public boolean setMarkAt(Symbol symbol, int boardIndex, int markIndex) throws IllegalArgumentException {
        if (symbol == null || boardIndex < 0 || boardIndex > 8 || markIndex < 0
                || markIndex > 8) {
            throw new IllegalArgumentException();
        }

        if (this.lastSymbolIndex == boardIndex || this.lastSymbolIndex == -1) {
            this.boards[boardIndex].setMarkAt(symbol, markIndex);
            updateLastSymbolIndex(markIndex);
            return true;
        }

        return false;

    }

    public int getIndexNextBoard() {
        return this.lastSymbolIndex;
    }

    public void setIndexNextBoard(int index) throws IllegalArgumentException {
        if (index > 8 || index < -1) {
            throw new IllegalArgumentException();

        }
        this.lastSymbolIndex = index;
    }

    // Not generated by chatGPT but basically just slightly changed the code
    // generated from chatGPT in boardimplementation to adjust for the winner

    public Symbol getWinner() {
        int[][] winningCombinations = {
                { 0, 1, 2 }, { 3, 4, 5 }, { 6, 7, 8 }, // Rows
                { 0, 3, 6 }, { 1, 4, 7 }, { 2, 5, 8 }, // Columns
                { 0, 4, 8 }, { 2, 4, 6 } // Diagonals
        };

        for (int[] combination : winningCombinations) {
            BoardInterface board1 = boards[combination[0]];
            BoardInterface board2 = boards[combination[1]];
            BoardInterface board3 = boards[combination[2]];

            Symbol symbol1 = board1.getWinner();
            Symbol symbol2 = board2.getWinner();
            Symbol symbol3 = board3.getWinner();

            if (symbol1 != Symbol.EMPTY &&
                    symbol1 == symbol2 &&
                    symbol1 == symbol3) {
                return symbol1; // Winning symbol found
            }
        }

        return Symbol.EMPTY;

    }

    public boolean isGameOver() {

        if (getWinner() != Symbol.EMPTY) {
            return true;
        }

        for (int i = 0; i < 9; i++) {
            if (!this.boards[i].isClosed()) {
                return false;
            }
        }

        return true;

    }

    public boolean isMovePossible(int boardIndex) throws IllegalArgumentException {
        if (boardIndex < 0 || boardIndex > 8) {
            throw new IllegalArgumentException();
        }

        if (isGameOver()) {
            return false;
        }

        if (boards[boardIndex].isClosed()) {
            return false;
        }

        if (this.lastSymbolIndex == -1) {
            return true;
        }

        return (boardIndex == this.lastSymbolIndex);
    }

    public boolean isMovePossible(int boardIndex, int markIndex) throws IllegalArgumentException {
        if (boardIndex < 0 || boardIndex > 8 || markIndex < 0 || markIndex > 8) {
            throw new IllegalArgumentException("index out of range");
        }

        if (isGameOver()) {
            System.out.println("game over");
            return false;
        }

        if (this.boards[boardIndex].getMarks()[markIndex].getSymbol() != Symbol.EMPTY) {
            System.out.println("symbol is not empty");
            return false;
        }

        if (this.boards[boardIndex].isClosed()) {
            System.out.println("board is closed");
            return false;
        }

        if (this.lastSymbolIndex == -1 || this.lastSymbolIndex == boardIndex) {
            System.out.println("wong board location");
            return true;
        }

        return false;
    }

    @Override
    public void run(PlayerInterface playerOne, PlayerInterface playerTwo, UserInterface ui)
            throws IllegalArgumentException {
        setCurrentPlayerSymbol(Symbol.CROSS);
        while (!isGameOver()) {
            PlayerInterface currentPlayer = this.getCurrentPlayerSymbol() == Symbol.CROSS ? playerOne : playerTwo;
            Move nextMove = currentPlayer.getPlayerMove(this, ui);
            this.setMarkAt(currentPlayerSymbol, nextMove.getBoardIndex(), nextMove.getMarkIndex());
            this.currentPlayerSymbol = this.currentPlayerSymbol == Symbol.CROSS ? Symbol.CIRCLE : Symbol.CROSS;
            ui.updateScreen(this);
        }

        ui.showGameOverScreen(this.getWinner());

    }

}
